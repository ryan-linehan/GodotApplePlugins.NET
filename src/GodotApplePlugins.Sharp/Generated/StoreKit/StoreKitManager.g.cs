// <auto-generated>
// This code was generated by GodotApplePlugins.Generator.
// Do not edit this file directly. Edit the generator instead.
// </auto-generated>

#nullable enable

using Godot;
using System;
using System.Linq;
using System.Threading.Tasks;

namespace GodotApplePlugins.NET.StoreKit;

/// <summary>
/// Manages StoreKit interactions such as requesting products, purchasing, and restoring purchases.
/// </summary>
public partial class StoreKitManager : GodotObject
{
    #region StringName Constants

    private static readonly StringName _methodFetchCurrentEntitlements = "fetch_current_entitlements";
    private static readonly StringName _methodPurchase = "purchase";
    private static readonly StringName _methodPurchaseWithOptions = "purchase_with_options";
    private static readonly StringName _methodRequestProducts = "request_products";
    private static readonly StringName _methodRestorePurchases = "restore_purchases";
    private static readonly StringName _signalProductsRequestCompleted = "products_request_completed";
    private static readonly StringName _signalPurchaseCompleted = "purchase_completed";
    private static readonly StringName _signalPurchaseIntent = "purchase_intent";
    private static readonly StringName _signalRestoreCompleted = "restore_completed";
    private static readonly StringName _signalSupscriptionUpdate = "supscription_update";
    private static readonly StringName _signalTransactionUpdated = "transaction_updated";
    private static readonly StringName _signalUnverifiedTransactionUpdated = "unverified_transaction_updated";

    #endregion

    private readonly GodotObject _instance;

    /// <summary>
    /// Creates a new StoreKitManager wrapper.
    /// </summary>
    public StoreKitManager(GodotObject instance)
    {
        _instance = instance ?? throw new ArgumentNullException(nameof(instance));
        ConnectSignals();
    }

    /// <summary>
    /// Gets the underlying GDExtension object.
    /// </summary>
    public GodotObject Instance => _instance;

    /// <summary>
    /// The current entitlements sequence provides the most recent transaction for each product the customer is entitled to, use this to refresh the list of features the user is entitled to. Specifically, it includes: * One transaction for each non-consumable In-App Purchase * The latest transaction for each auto-renewable subscription whose Product.SubscriptionInfo.RenewalState is either subscribed or inGracePeriod * The latest transaction for each non-renewing subscription, including those that have ended * Products that have been refunded or revoked by the App Store are excluded from the current entitlements, as are consumable In-App Purchases. To retrieve transactions for unfinished consumables, use the unfinished or all transaction sequences instead.
    /// </summary>
    public void FetchCurrentEntitlements()
    {
        _instance.Call(_methodFetchCurrentEntitlements);
    }

    /// <summary>
    /// Initiates the purchase of a specific product, e.g. 'purchase(product)'. This will raise the purchase_completed signal, either to indicate that an error took place, or the status of the purchase.
    /// </summary>
    public void Purchase(StoreProduct product)
    {
        _instance.Call(_methodPurchase, product.Instance);
    }

    /// <summary>
    /// Async version of Purchase that awaits the PurchaseCompleted signal.
    /// </summary>
    public async Task<(StoreTransaction, int, string)> PurchaseAsync(StoreProduct product)
    {
        _instance.Call(_methodPurchase, product.Instance);
        var result = await ToSignal(this, SignalName.PurchaseCompleted);
        return (new StoreTransaction(result[0].AsGodotObject()), result[1].AsInt32(), result[2].AsString());
    }

    /// <summary>
    /// Initiates the purchase of a specific product, e.g. 'purchase(product)', and allows you to provide additional purchase options. This will raise the purchase_completed signal, either to indicate that an error took place, or the status of the purchase.
    /// </summary>
    public void PurchaseWithOptions(StoreProduct product, StoreProductPurchaseOption[] options)
    {
        _instance.Call(_methodPurchaseWithOptions, product.Instance, new Godot.Collections.Array(options.Select(x => Variant.From(x.Instance))));
    }

    /// <summary>
    /// Requests product information for a list of product identifiers, e.g. 'request_products(["com.example.product1", "com.example.product2"])'. This method will raise the products_request_completed signal when the information is retrieved.
    /// </summary>
    public void RequestProducts(string[] productids)
    {
        _instance.Call(_methodRequestProducts, productids);
    }

    /// <summary>
    /// Async version of RequestProducts that awaits the ProductsRequestCompleted signal.
    /// </summary>
    public async Task<(StoreProduct[], int)> RequestProductsAsync(string[] productids)
    {
        _instance.Call(_methodRequestProducts, productids);
        var result = await ToSignal(this, SignalName.ProductsRequestCompleted);
        return (result[0].AsGodotArray().Select(x => new StoreProduct((GodotObject)x.Obj!)).ToArray(), result[1].AsInt32());
    }

    /// <summary>
    /// Restores previously purchased non-consumable products and auto-renewable subscriptions. This will raise the restore_completed signal when the product purchased have been restored.
    /// </summary>
    public void RestorePurchases()
    {
        _instance.Call(_methodRestorePurchases);
    }

    /// <summary>
    /// Async version of RestorePurchases that awaits the RestoreCompleted signal.
    /// </summary>
    public async Task<(int, string)> RestorePurchasesAsync()
    {
        _instance.Call(_methodRestorePurchases);
        var result = await ToSignal(this, SignalName.RestoreCompleted);
        return (result[0].AsInt32(), result[1].AsString());
    }

    #region Signals

    /// <summary>
    /// Emitted when a product request completes. products is an Array of StoreProducts (or nulls). status indicates success or failure.
    /// </summary>
    [Signal]
    public delegate void ProductsRequestCompletedEventHandler(StoreProduct[] products, int status);

    /// <summary>
    /// Emitted when a purchase completes. transaction is the StoreTransaction on success. status indicates the result (OK, cancelled, invalid product, etc.). error_message contains error details if failed.
    /// </summary>
    [Signal]
    public delegate void PurchaseCompletedEventHandler(StoreTransaction transaction, int status, string message);

    [Signal]
    public delegate void PurchaseIntentEventHandler(StoreProduct product);

    /// <summary>
    /// Emitted when the restore process completes. `arg1` is the StoreKitStatus, and `arg2` is an error message if applicable.
    /// </summary>
    [Signal]
    public delegate void RestoreCompletedEventHandler(int status, string message);

    [Signal]
    public delegate void SupscriptionUpdateEventHandler(StoreSubscriptionInfoStatus status);

    /// <summary>
    /// Emitted when a transaction is updated (e.g., a subscription renews or a purchase is approved externally). `transaction` is the updated StoreTransaction. You must call the finished method on the transaction once you have made sure that you have delivered the content to the user.
    /// </summary>
    [Signal]
    public delegate void TransactionUpdatedEventHandler(StoreTransaction transaction);

    [Signal]
    public delegate void UnverifiedTransactionUpdatedEventHandler(StoreTransaction transaction, int verificationError);

    private void ConnectSignals()
    {
        _instance.Connect(_signalProductsRequestCompleted,
            Callable.From<Godot.Collections.Array, int>((p0, p1) =>
                EmitSignal(SignalName.ProductsRequestCompleted, p0.Select(x => new StoreProduct((GodotObject)x.Obj!)).ToArray(), p1)));

        _instance.Connect(_signalPurchaseCompleted,
            Callable.From<GodotObject, int, string>((p0, p1, p2) =>
                EmitSignal(SignalName.PurchaseCompleted, new StoreTransaction(p0), p1, p2)));

        _instance.Connect(_signalPurchaseIntent,
            Callable.From<GodotObject>((p0) =>
                EmitSignal(SignalName.PurchaseIntent, new StoreProduct(p0))));

        _instance.Connect(_signalRestoreCompleted,
            Callable.From<int, string>((p0, p1) =>
                EmitSignal(SignalName.RestoreCompleted, p0, p1)));

        _instance.Connect(_signalSupscriptionUpdate,
            Callable.From<GodotObject>((p0) =>
                EmitSignal(SignalName.SupscriptionUpdate, new StoreSubscriptionInfoStatus(p0))));

        _instance.Connect(_signalTransactionUpdated,
            Callable.From<GodotObject>((p0) =>
                EmitSignal(SignalName.TransactionUpdated, new StoreTransaction(p0))));

        _instance.Connect(_signalUnverifiedTransactionUpdated,
            Callable.From<GodotObject, int>((p0, p1) =>
                EmitSignal(SignalName.UnverifiedTransactionUpdated, new StoreTransaction(p0), p1)));

    }

    #endregion
}
