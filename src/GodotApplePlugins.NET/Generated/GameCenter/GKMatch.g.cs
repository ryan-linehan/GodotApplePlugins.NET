// <auto-generated>
// This code was generated by GodotApplePlugins.Generator.
// Do not edit this file directly. Edit the generator instead.
// </auto-generated>

#nullable enable

using Godot;
using System;
using System.Linq;
using System.Threading.Tasks;

namespace GodotApplePlugins.NET.GameCenter;

/// <summary>
/// Represents an active real-time Game Center match.
/// </summary>
public partial class GKMatch : GodotObject
{
    #region StringName Constants

    private static readonly StringName _methodDisconnect = "disconnect";
    private static readonly StringName _methodSend = "send";
    private static readonly StringName _methodSendDataToAllPlayers = "send_data_to_all_players";
    private static readonly StringName _propertyExpectedPlayerCount = "expected_player_count";
    private static readonly StringName _propertyPlayers = "players";
    private static readonly StringName _propertyShouldReinviteDisconnectedPlayer = "should_reinvite_disconnected_player";
    private static readonly StringName _signalDataReceived = "data_received";
    private static readonly StringName _signalDataReceivedForRecipientFromPlayer = "data_received_for_recipient_from_player";
    private static readonly StringName _signalDidFailWithError = "did_fail_with_error";
    private static readonly StringName _signalPlayerChanged = "player_changed";

    #endregion

    private readonly GodotObject _instance;

    /// <summary>
    /// Creates a new GKMatch wrapper.
    /// </summary>
    public GKMatch(GodotObject instance)
    {
        _instance = instance ?? throw new ArgumentNullException(nameof(instance));
        ConnectSignals();
    }

    /// <summary>
    /// Gets the underlying GDExtension object.
    /// </summary>
    public GodotObject Instance => _instance;

    /// <summary>
    /// The number of additional players that GameKit is recruiting before the match can begin.
    /// </summary>
    public int ExpectedPlayerCount
    {
        get => _instance.Get(_propertyExpectedPlayerCount).AsInt32();
        set => _instance.Set(_propertyExpectedPlayerCount, value);
    }

    /// <summary>
    /// Array of [code skip-lint]GKPlayer[/code] instances that are currently connected.
    /// </summary>
    public Godot.Collections.Array Players
    {
        get => _instance.Get(_propertyPlayers).AsGodotArray();
        set => _instance.Set(_propertyPlayers, value);
    }

    /// <summary>
    /// Optional [code skip-lint]Callable[/code] that receives a [code skip-lint]GKPlayer[/code] and returns [code]true[/code] if the player should be reinvited after disconnecting (see the sample in [code skip-lint]GameCenterGuide.md[/code]).
    /// </summary>
    public Variant ShouldReinviteDisconnectedPlayer
    {
        get => _instance.Get(_propertyShouldReinviteDisconnectedPlayer);
        set => _instance.Set(_propertyShouldReinviteDisconnectedPlayer, value);
    }

    /// <summary>
    /// Calls [code skip-lint]GKMatch.disconnect()' to leave the match immediately.
    /// </summary>
    public void Disconnect()
    {
        _instance.Call(_methodDisconnect);
    }

    /// <summary>
    /// Sends a payload to the specified [code skip-lint]ArrayGKPlayer'. Returns a [enum @GlobalScope.Error] value ([code skip-lint]OK' on success, [code skip-lint]FAILED' when the payload could not be converted or Apple reported an error). Choose a SendDataMode constant for dataMode.
    /// </summary>
    public int Send(byte[] data, Godot.Collections.Array toplayers, GodotObject datamode)
    {
        var result = _instance.Call(_methodSend, data, toplayers, datamode);
        return result.AsInt32();
    }

    /// <summary>
    /// Broadcasts the packed bytes to everyone in the match. Return value matches send. Use the SendDataMode constants.
    /// </summary>
    public int SendDataToAllPlayers(byte[] data, GodotObject datamode)
    {
        var result = _instance.Call(_methodSendDataToAllPlayers, data, datamode);
        return result.AsInt32();
    }

    #region Signals

    /// <summary>
    /// Emitted when another player sends data to the local device. Provides the raw bytes and the sender.
    /// </summary>
    [Signal]
    public delegate void DataReceivedEventHandler(byte[] data, GKPlayer player);

    /// <summary>
    /// Emitted when the local player receives data that was addressed to a specific recipient. Arguments provide the payload, the intended recipient, and the sender.
    /// </summary>
    [Signal]
    public delegate void DataReceivedForRecipientFromPlayerEventHandler(byte[] data, GKPlayer recipient, GKPlayer fromRemotePlayer);

    /// <summary>
    /// Fires when Apple reports a networking error. The [code skip-lint]String' argument contains the localized description.
    /// </summary>
    [Signal]
    public delegate void DidFailWithErrorEventHandler(string message);

    /// <summary>
    /// Notifies you when a player connects or disconnects. The boolean is 'true' for connected players and 'false' otherwise.
    /// </summary>
    [Signal]
    public delegate void PlayerChangedEventHandler(GKPlayer player, bool connected);

    private void ConnectSignals()
    {
        _instance.Connect(_signalDataReceived,
            Callable.From<byte[], GodotObject>((p0, p1) =>
                EmitSignal(SignalName.DataReceived, p0, new GKPlayer(p1))));

        _instance.Connect(_signalDataReceivedForRecipientFromPlayer,
            Callable.From<byte[], GodotObject, GodotObject>((p0, p1, p2) =>
                EmitSignal(SignalName.DataReceivedForRecipientFromPlayer, p0, new GKPlayer(p1), new GKPlayer(p2))));

        _instance.Connect(_signalDidFailWithError,
            Callable.From<string>((p0) =>
                EmitSignal(SignalName.DidFailWithError, p0)));

        _instance.Connect(_signalPlayerChanged,
            Callable.From<GodotObject, bool>((p0, p1) =>
                EmitSignal(SignalName.PlayerChanged, new GKPlayer(p0), p1)));

    }

    #endregion
}
