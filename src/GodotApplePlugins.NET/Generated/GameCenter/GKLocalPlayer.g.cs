// <auto-generated>
// This code was generated by GodotApplePlugins.Generator.
// Do not edit this file directly. Edit the generator instead.
// </auto-generated>

#nullable enable

using Godot;
using System;
using System.Linq;
using System.Threading.Tasks;

namespace GodotApplePlugins.NET.GameCenter;

/// <summary>
/// Represents the signed-in Game Center player and exposes local-only APIs.
/// </summary>
public partial class GKLocalPlayer : GodotObject
{
    #region StringName Constants

    private static readonly StringName _methodDeleteSavedGames = "delete_saved_games";
    private static readonly StringName _methodFetchItemsForIdentityVerificationSignature = "fetch_items_for_identity_verification_signature";
    private static readonly StringName _methodFetchSavedGames = "fetch_saved_games";
    private static readonly StringName _methodLoadChallengeableFriends = "load_challengeable_friends";
    private static readonly StringName _methodLoadFriends = "load_friends";
    private static readonly StringName _methodLoadRecentFriends = "load_recent_friends";
    private static readonly StringName _methodRegisterListener = "register_listener";
    private static readonly StringName _methodResolveConflictingSavedGames = "resolve_conflicting_saved_games";
    private static readonly StringName _methodSaveGameData = "save_game_data";
    private static readonly StringName _methodUnregisterListener = "unregister_listener";
    private static readonly StringName _propertyIsAuthenticated = "is_authenticated";
    private static readonly StringName _propertyIsMultiplayerGamingRestricted = "is_multiplayer_gaming_restricted";
    private static readonly StringName _propertyIsPersonalizedCommunicationRestricted = "is_personalized_communication_restricted";
    private static readonly StringName _propertyIsUnderage = "is_underage";
    private static readonly StringName _signalConflictingSavedGames = "conflicting_saved_games";
    private static readonly StringName _signalSavedGameModified = "saved_game_modified";

    #endregion

    private readonly GodotObject _instance;

    /// <summary>
    /// Creates a new GKLocalPlayer wrapper.
    /// </summary>
    public GKLocalPlayer(GodotObject instance)
    {
        _instance = instance ?? throw new ArgumentNullException(nameof(instance));
        ConnectSignals();
    }

    /// <summary>
    /// Gets the underlying GDExtension object.
    /// </summary>
    public GodotObject Instance => _instance;

    /// <summary>
    /// Reflects [code skip-lint]GKLocalPlayer.local.isAuthenticated[/code].
    /// </summary>
    public bool IsAuthenticated
    {
        get => _instance.Get(_propertyIsAuthenticated).AsBool();
        set => _instance.Set(_propertyIsAuthenticated, value);
    }

    /// <summary>
    /// True when multiplayer is disabled by parental controls.
    /// </summary>
    public bool IsMultiplayerGamingRestricted
    {
        get => _instance.Get(_propertyIsMultiplayerGamingRestricted).AsBool();
        set => _instance.Set(_propertyIsMultiplayerGamingRestricted, value);
    }

    /// <summary>
    /// Indicates whether personalized communication is blocked for this account.
    /// </summary>
    public bool IsPersonalizedCommunicationRestricted
    {
        get => _instance.Get(_propertyIsPersonalizedCommunicationRestricted).AsBool();
        set => _instance.Set(_propertyIsPersonalizedCommunicationRestricted, value);
    }

    /// <summary>
    /// Apple's [code]isUnderage[/code] flag for COPPA-compliant flows.
    /// </summary>
    public bool IsUnderage
    {
        get => _instance.Get(_propertyIsUnderage).AsBool();
        set => _instance.Set(_propertyIsUnderage, value);
    }

    public void DeleteSavedGames(string named, Callable callback)
    {
        _instance.Call(_methodDeleteSavedGames, named, callback);
    }

    /// <summary>
    /// Calls Apple's 'fetchItems' helper for server-side authentication. The callback receives '(Dictionary data, Variant error)'. The dictionary contains the 'url', 'data', 'salt', and 'timestamp' keys described in the inline Swift documentation, letting your backend verify the player's identity. If not null, 'error' contains a GKError.
    /// </summary>
    public void FetchItemsForIdentityVerificationSignature(Callable callback)
    {
        _instance.Call(_methodFetchItemsForIdentityVerificationSignature, callback);
    }

    /// <summary>
    /// Use this API to retrieve the list of saved games, upon completion, this method invokes the provided callback with both an array of GKSavedGame objects and a variant error, if not nil it contains a GKError describing the problem.
    /// </summary>
    public void FetchSavedGames(Callable callback)
    {
        _instance.Call(_methodFetchSavedGames, callback);
    }

    /// <summary>
    /// Loads players whom the local user can challenge. The callback receives '(ArrayGKPlayer friends, Variant error)' where either argument can be 'null'. If error is present, it is a GKError.
    /// </summary>
    public void LoadChallengeableFriends(Callable callback)
    {
        _instance.Call(_methodLoadChallengeableFriends, callback);
    }

    /// <summary>
    /// Fetches the friends list. The callback receives '(ArrayGKPlayer friends, Variant error)'; a non-null error [code skip-lint]Variant' holds the GKError.
    /// </summary>
    public void LoadFriends(Callable callback)
    {
        _instance.Call(_methodLoadFriends, callback);
    }

    /// <summary>
    /// Loads friends that recently played together with the local player. The callback signature matches load_challengeable_friends.
    /// </summary>
    public void LoadRecentFriends(Callable callback)
    {
        _instance.Call(_methodLoadRecentFriends, callback);
    }

    /// <summary>
    /// Saves the packed byte array as the game data with the specified name, upon completion the callback is invoked with both a GKSavedObject parameter and a Variant parameter for the error. The GKSavedObject is not-nil on success, and on error, the second parameter is not-nil and contains the GKError.
    /// </summary>
    public void SaveGameData(byte[] data, string withname, Callable callback)
    {
        _instance.Call(_methodSaveGameData, data, withname, callback);
    }

    /// <summary>
    /// Registers the local player listener to receive events like saved game conflicts. You typically call this in your '_ready()' function.
    /// </summary>
    public void RegisterListener()
    {
        _instance.Call(_methodRegisterListener);
    }

    /// <summary>
    /// Unregisters the local player listener.
    /// </summary>
    public void UnregisterListener()
    {
        _instance.Call(_methodUnregisterListener);
    }

    /// <summary>
    /// Resolves conflicting saved games using the provided data. The 'conflicts' array should contain the GKSavedGame objects that are in conflict (received from the conflicting_saved_games). The 'data' is the correct game data to save. The callback receives '(ArrayGKSavedGame saved_games, Variant error)'. 'error' is a GKError if not null.
    /// </summary>
    public void ResolveConflictingSavedGames(Godot.Collections.Array conflicts, byte[] data, Callable callback)
    {
        _instance.Call(_methodResolveConflictingSavedGames, conflicts, data, callback);
    }

    #region Signals

    /// <summary>
    /// Emitted when there is a conflict between saved games. You should listen to this signal and then call resolve_conflicting_saved_games with the chosen data.
    /// </summary>
    [Signal]
    public delegate void ConflictingSavedGamesEventHandler(GKPlayer player, Godot.Collections.Array conflictingSavedGames);

    /// <summary>
    /// Emitted when a saved game is modified.
    /// </summary>
    [Signal]
    public delegate void SavedGameModifiedEventHandler(GKPlayer player, GKSavedGame savedGame);

    private void ConnectSignals()
    {
        _instance.Connect(_signalConflictingSavedGames,
            Callable.From<GodotObject, Godot.Collections.Array>((p0, p1) =>
                EmitSignal(SignalName.ConflictingSavedGames, new GKPlayer(p0), p1)));

        _instance.Connect(_signalSavedGameModified,
            Callable.From<GodotObject, GodotObject>((p0, p1) =>
                EmitSignal(SignalName.SavedGameModified, new GKPlayer(p0), new GKSavedGame(p1))));

    }

    #endregion
}
