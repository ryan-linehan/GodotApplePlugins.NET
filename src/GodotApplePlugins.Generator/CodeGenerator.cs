using System.Text;

namespace GodotApplePlugins.Generator;

/// <summary>
/// Generates C# wrapper code from parsed GdClass models.
/// </summary>
public class CodeGenerator
{
    private readonly string _outputPath;

    public CodeGenerator(string outputPath)
    {
        _outputPath = outputPath;
    }

    /// <summary>
    /// Generates all classes.
    /// </summary>
    public void GenerateAll(List<GdClass> classes)
    {
        // Group by namespace
        var byNamespace = classes.GroupBy(c => TypeMapper.GetNamespace(c.Name));

        foreach (var group in byNamespace)
        {
            var namespaceDir = Path.Combine(_outputPath, group.Key.Replace("GodotApplePlugins.NET.", "").Replace(".", "/"));
            Directory.CreateDirectory(namespaceDir);

            foreach (var gdClass in group)
            {
                var code = GenerateClass(gdClass);
                var filePath = Path.Combine(namespaceDir, $"{gdClass.Name}.g.cs");
                File.WriteAllText(filePath, code);
                Console.WriteLine($"Generated: {filePath}");
            }
        }

        // Generate enums file
        GenerateEnums(classes);

        // Generate ApplePlugins factory class
        GenerateApplePlugins(classes);
    }

    /// <summary>
    /// Generates code for a single class.
    /// </summary>
    public string GenerateClass(GdClass gdClass)
    {
        var sb = new StringBuilder();
        var ns = TypeMapper.GetNamespace(gdClass.Name);

        // Collect all referenced wrapped types from signals and methods
        var referencedTypes = new HashSet<string>();
        foreach (var signal in gdClass.Signals)
        {
            foreach (var param in signal.Parameters)
            {
                AddReferencedTypes(param.Type, referencedTypes);
            }
        }
        foreach (var method in gdClass.Methods)
        {
            AddReferencedTypes(method.ReturnType, referencedTypes);
            foreach (var param in method.Parameters)
            {
                AddReferencedTypes(param.Type, referencedTypes);
            }
        }
        foreach (var prop in gdClass.Properties)
        {
            AddReferencedTypes(prop.Type, referencedTypes);
        }

        // Get namespaces needed for referenced types
        var requiredNamespaces = referencedTypes
            .Where(TypeMapper.IsWrappedClass)
            .Select(TypeMapper.GetNamespace)
            .Where(refNs => refNs != ns) // Exclude current namespace
            .Distinct()
            .OrderBy(n => n)
            .ToList();

        // File header
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This code was generated by GodotApplePlugins.Generator.");
        sb.AppendLine("// Do not edit this file directly. Edit the generator instead.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Godot;");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Threading.Tasks;");

        // Add using directives for referenced types from other namespaces
        foreach (var refNs in requiredNamespaces)
        {
            sb.AppendLine($"using {refNs};");
        }

        sb.AppendLine();
        sb.AppendLine($"namespace {ns};");
        sb.AppendLine();

        // Class XML doc
        if (!string.IsNullOrEmpty(gdClass.Description))
        {
            sb.AppendLine("/// <summary>");
            foreach (var line in gdClass.Description.Split('\n'))
            {
                sb.AppendLine($"/// {EscapeXml(line.Trim())}");
            }
            sb.AppendLine("/// </summary>");
        }

        // Class declaration - inherit from GodotObject to support [Signal]
        sb.AppendLine($"public partial class {gdClass.Name} : GodotObject");
        sb.AppendLine("{");

        // Private field
        sb.AppendLine("    private readonly GodotObject _instance;");
        sb.AppendLine();

        // Constructor
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Creates a new {gdClass.Name} wrapper.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public {gdClass.Name}(GodotObject instance)");
        sb.AppendLine("    {");
        sb.AppendLine("        _instance = instance ?? throw new ArgumentNullException(nameof(instance));");

        // Connect signals in constructor
        if (gdClass.Signals.Count > 0)
        {
            sb.AppendLine("        ConnectSignals();");
        }

        sb.AppendLine("    }");
        sb.AppendLine();

        // Instance property
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets the underlying GDExtension object.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public GodotObject Instance => _instance;");
        sb.AppendLine();

        // Generate properties
        foreach (var prop in gdClass.Properties)
        {
            GenerateProperty(sb, prop);
        }

        // Generate methods (pass signals for async variant generation)
        foreach (var method in gdClass.Methods)
        {
            GenerateMethod(sb, method, gdClass.Signals);
        }

        // Generate signal events
        if (gdClass.Signals.Count > 0)
        {
            GenerateSignals(sb, gdClass.Signals);
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private void GenerateProperty(StringBuilder sb, GdProperty prop)
    {
        var csharpType = TypeMapper.GetCSharpType(prop.Type);
        var propName = TypeMapper.ToPascalCase(prop.Name);

        // XML doc
        if (!string.IsNullOrEmpty(prop.Description))
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// {EscapeXml(prop.Description)}");
            sb.AppendLine("    /// </summary>");
        }

        var getterCode = TypeMapper.GetFromGodotConversion($"_instance.Get(new StringName(\"{prop.Name}\"))", prop.Type);

        if (prop.HasSetter)
        {
            var setterConversion = TypeMapper.GetToGodotConversion("value", prop.Type);
            sb.AppendLine($"    public {csharpType} {propName}");
            sb.AppendLine("    {");
            sb.AppendLine($"        get => {getterCode};");
            sb.AppendLine($"        set => _instance.Set(new StringName(\"{prop.Name}\"), {setterConversion});");
            sb.AppendLine("    }");
        }
        else
        {
            sb.AppendLine($"    public {csharpType} {propName} => {getterCode};");
        }

        sb.AppendLine();
    }

    private void GenerateMethod(StringBuilder sb, GdMethod method, List<GdSignal> signals)
    {
        var methodName = TypeMapper.ToPascalCase(method.Name);
        var returnType = TypeMapper.GetCSharpType(method.ReturnType);
        var hasReturn = method.ReturnType != "void";

        // Check if last param is Callable (callback pattern)
        var isCallbackMethod = method.Parameters.LastOrDefault()?.Type == "Callable";

        // XML doc
        if (!string.IsNullOrEmpty(method.Description))
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// {EscapeXml(method.Description)}");
            sb.AppendLine("    /// </summary>");
        }

        // Build parameter list (excluding Callable params for sync version)
        var paramList = new List<string>();
        var paramListForAsync = new List<string>();
        foreach (var param in method.Parameters)
        {
            if (param.Type == "Callable")
            {
                // Convert callback to Action/Func
                paramList.Add($"Action? {TypeMapper.ToCamelCase(param.Name)} = null");
                // Skip Callable params in async version
            }
            else
            {
                var paramType = TypeMapper.GetCSharpType(param.Type);
                var paramName = TypeMapper.ToCamelCase(param.Name);

                // Avoid C# reserved keywords
                if (paramName == "params") paramName = "@params";
                if (paramName == "event") paramName = "@event";
                if (paramName == "class") paramName = "@class";

                paramList.Add($"{paramType} {paramName}");
                paramListForAsync.Add($"{paramType} {paramName}");
            }
        }

        var paramsStr = string.Join(", ", paramList);
        sb.AppendLine($"    public {returnType} {methodName}({paramsStr})");
        sb.AppendLine("    {");

        // Build call arguments
        var callArgs = new List<string>();
        callArgs.Add($"new StringName(\"{method.Name}\")");

        foreach (var param in method.Parameters)
        {
            var paramName = TypeMapper.ToCamelCase(param.Name);
            if (paramName == "params") paramName = "@params";
            if (paramName == "event") paramName = "@event";
            if (paramName == "class") paramName = "@class";

            if (param.Type == "Callable")
            {
                callArgs.Add($"{paramName} != null ? Callable.From(() => {paramName}()) : Callable.From(() => {{ }})");
            }
            else
            {
                callArgs.Add(TypeMapper.GetToGodotConversion(paramName, param.Type));
            }
        }

        var callArgsStr = string.Join(", ", callArgs);

        if (hasReturn)
        {
            sb.AppendLine($"        var result = _instance.Call({callArgsStr});");
            var conversion = TypeMapper.GetFromGodotConversion("result", method.ReturnType);
            sb.AppendLine($"        return {conversion};");
        }
        else
        {
            sb.AppendLine($"        _instance.Call({callArgsStr});");
        }

        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate async version if there's a matching signal
        var matchingSignal = FindMatchingSignal(method.Name, signals);
        if (matchingSignal != null && !hasReturn)
        {
            GenerateAsyncMethod(sb, method, matchingSignal, paramListForAsync);
        }
    }

    /// <summary>
    /// Finds a signal that corresponds to a method's completion.
    /// </summary>
    private GdSignal? FindMatchingSignal(string methodName, List<GdSignal> signals)
    {
        // Common patterns:
        // authenticate -> authentication_result, authentication_error
        // request_products -> products_request_completed
        // fetch_* -> *_completed, *_loaded
        // load_* -> *_loaded, *_completed
        // purchase -> purchase_completed
        // restore_purchases -> restore_completed

        foreach (var signal in signals)
        {
            var signalName = signal.Name.ToLower();
            var method = methodName.ToLower();

            // Direct match patterns
            if (method == "authenticate" && signalName == "authentication_result") return signal;
            if (method == "request_products" && signalName == "products_request_completed") return signal;
            if (method == "purchase" && signalName == "purchase_completed") return signal;
            if (method == "restore_purchases" && signalName == "restore_completed") return signal;

            // fetch_X -> X_completed or fetched_X
            if (method.StartsWith("fetch_"))
            {
                var suffix = method.Replace("fetch_", "");
                if (signalName == $"{suffix}_completed" || signalName == $"{suffix}_loaded" ||
                    signalName == $"fetched_{suffix}" || signalName == $"{suffix}_fetched")
                    return signal;
            }

            // load_X -> X_loaded or X_completed
            if (method.StartsWith("load_"))
            {
                var suffix = method.Replace("load_", "");
                if (signalName == $"{suffix}_loaded" || signalName == $"{suffix}_completed")
                    return signal;
            }

            // X -> X_completed or X_result
            if (signalName == $"{method}_completed" || signalName == $"{method}_result")
                return signal;
        }

        return null;
    }

    /// <summary>
    /// Generates an async version of a method that awaits its result signal.
    /// </summary>
    private void GenerateAsyncMethod(StringBuilder sb, GdMethod method, GdSignal signal, List<string> paramList)
    {
        var methodName = TypeMapper.ToPascalCase(method.Name);
        var signalName = TypeMapper.ToPascalCase(signal.Name);
        var paramsStr = string.Join(", ", paramList);

        // Determine return type based on signal parameters
        string asyncReturnType;
        if (signal.Parameters.Count == 0)
        {
            asyncReturnType = "Task";
        }
        else if (signal.Parameters.Count == 1)
        {
            asyncReturnType = $"Task<{TypeMapper.GetCSharpType(signal.Parameters[0].Type)}>";
        }
        else
        {
            // Multiple params - return a tuple
            var tupleTypes = string.Join(", ", signal.Parameters.Select(p => TypeMapper.GetCSharpType(p.Type)));
            asyncReturnType = $"Task<({tupleTypes})>";
        }

        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Async version of {methodName} that awaits the {signalName} signal.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public async {asyncReturnType} {methodName}Async({paramsStr})");
        sb.AppendLine("    {");

        // Build call args (without Callable)
        var callArgs = new List<string> { $"new StringName(\"{method.Name}\")" };
        foreach (var param in method.Parameters.Where(p => p.Type != "Callable"))
        {
            var paramName = TypeMapper.ToCamelCase(param.Name);
            if (paramName == "params") paramName = "@params";
            if (paramName == "event") paramName = "@event";
            if (paramName == "class") paramName = "@class";
            callArgs.Add(TypeMapper.GetToGodotConversion(paramName, param.Type));
        }
        var callArgsStr = string.Join(", ", callArgs);

        sb.AppendLine($"        _instance.Call({callArgsStr});");
        sb.AppendLine($"        var result = await ToSignal(this, SignalName.{signalName});");

        // Return based on signal parameters
        if (signal.Parameters.Count == 0)
        {
            // No return needed for Task
        }
        else if (signal.Parameters.Count == 1)
        {
            var p = signal.Parameters[0];
            var conversion = GetSignalResultConversion("result[0]", p.Type);
            sb.AppendLine($"        return {conversion};");
        }
        else
        {
            // Build tuple return
            var tupleItems = signal.Parameters.Select((p, i) =>
            {
                var conversion = GetSignalResultConversion($"result[{i}]", p.Type);
                return conversion;
            });
            sb.AppendLine($"        return ({string.Join(", ", tupleItems)});");
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    /// <summary>
    /// Gets conversion code for signal result array element.
    /// </summary>
    private string GetSignalResultConversion(string expr, string godotType)
    {
        if (TypeMapper.IsWrappedClass(godotType))
        {
            return $"new {godotType}({expr}.AsGodotObject())";
        }

        return godotType switch
        {
            "bool" => $"{expr}.AsBool()",
            "int" => $"{expr}.AsInt32()",
            "float" => $"{expr}.AsDouble()",
            "String" => $"{expr}.AsString()",
            "string" => $"{expr}.AsString()",
            _ => $"{expr}.AsGodotObject()"
        };
    }

    private void GenerateSignals(StringBuilder sb, List<GdSignal> signals)
    {
        sb.AppendLine("    #region Signals");
        sb.AppendLine();

        // Generate [Signal] delegate declarations
        foreach (var signal in signals)
        {
            var eventName = TypeMapper.ToPascalCase(signal.Name);

            if (!string.IsNullOrEmpty(signal.Description))
            {
                sb.AppendLine("    /// <summary>");
                sb.AppendLine($"    /// {EscapeXml(signal.Description)}");
                sb.AppendLine("    /// </summary>");
            }

            sb.AppendLine("    [Signal]");
            if (signal.Parameters.Count == 0)
            {
                sb.AppendLine($"    public delegate void {eventName}EventHandler();");
            }
            else
            {
                // Build parameter list with names for the delegate
                var delegateParams = signal.Parameters.Select((p, i) =>
                {
                    var paramType = TypeMapper.GetCSharpType(p.Type);
                    var paramName = !string.IsNullOrEmpty(p.Name) ? TypeMapper.ToCamelCase(p.Name) : $"arg{i}";
                    return $"{paramType} {paramName}";
                });
                var delegateParamsStr = string.Join(", ", delegateParams);
                sb.AppendLine($"    public delegate void {eventName}EventHandler({delegateParamsStr});");
            }

            sb.AppendLine();
        }

        // Generate ConnectSignals method that forwards from GDExtension to our signals
        sb.AppendLine("    private void ConnectSignals()");
        sb.AppendLine("    {");

        foreach (var signal in signals)
        {
            var eventName = TypeMapper.ToPascalCase(signal.Name);

            if (signal.Parameters.Count == 0)
            {
                sb.AppendLine($"        _instance.Connect(new StringName(\"{signal.Name}\"),");
                sb.AppendLine($"            Callable.From(() => EmitSignal(SignalName.{eventName})));");
            }
            else
            {
                // Build Callable.From with proper types (raw Godot types for the callback)
                var paramTypes = string.Join(", ", signal.Parameters.Select(p =>
                {
                    return p.Type switch
                    {
                        _ when TypeMapper.IsWrappedClass(p.Type) => "GodotObject",
                        "Array" => "Godot.Collections.Array",
                        _ when p.Type.StartsWith("Array[") => "Godot.Collections.Array",
                        _ => TypeMapper.GetCSharpType(p.Type)
                    };
                }));

                var paramNames = signal.Parameters.Select((p, i) => $"p{i}").ToList();
                var paramNamesStr = string.Join(", ", paramNames);

                // Build EmitSignal args with conversions for wrapped types
                var emitArgs = new List<string> { $"SignalName.{eventName}" };
                for (int i = 0; i < signal.Parameters.Count; i++)
                {
                    var p = signal.Parameters[i];
                    if (TypeMapper.IsWrappedClass(p.Type))
                    {
                        emitArgs.Add($"new {p.Type}(p{i})");
                    }
                    else if (p.Type.StartsWith("Array["))
                    {
                        var innerType = p.Type.Replace("Array[", "").Replace("]", "");
                        if (TypeMapper.IsWrappedClass(innerType))
                        {
                            emitArgs.Add($"p{i}.Select(x => new {innerType}((GodotObject)x.Obj!)).ToArray()");
                        }
                        else
                        {
                            emitArgs.Add($"p{i}.Select(x => x.As<{TypeMapper.GetCSharpType(innerType)}>()).ToArray()");
                        }
                    }
                    else
                    {
                        emitArgs.Add($"p{i}");
                    }
                }
                var emitArgsStr = string.Join(", ", emitArgs);

                sb.AppendLine($"        _instance.Connect(new StringName(\"{signal.Name}\"),");
                sb.AppendLine($"            Callable.From<{paramTypes}>(({paramNamesStr}) =>");
                sb.AppendLine($"                EmitSignal({emitArgsStr})));");
            }

            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    #endregion");
    }

    private void GenerateEnums(List<GdClass> classes)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This code was generated by GodotApplePlugins.Generator.");
        sb.AppendLine("// Do not edit this file directly. Edit the generator instead.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("namespace GodotApplePlugins.NET;");
        sb.AppendLine();

        // Group constants by enum name
        var enumGroups = classes
            .SelectMany(c => c.Constants.Select(k => (Class: c, Constant: k)))
            .Where(x => !string.IsNullOrEmpty(x.Constant.EnumName))
            .GroupBy(x => $"{x.Class.Name}.{x.Constant.EnumName}");

        foreach (var group in enumGroups)
        {
            var enumName = group.Key.Split('.').Last();
            var className = group.Key.Split('.').First();

            sb.AppendLine($"/// <summary>");
            sb.AppendLine($"/// Enum from {className}.");
            sb.AppendLine($"/// </summary>");
            sb.AppendLine($"public enum {className}{enumName}");
            sb.AppendLine("{");

            foreach (var item in group)
            {
                var constName = TypeMapper.ToPascalCase(item.Constant.Name);
                if (!string.IsNullOrEmpty(item.Constant.Description))
                {
                    sb.AppendLine($"    /// <summary>{EscapeXml(item.Constant.Description)}</summary>");
                }
                sb.AppendLine($"    {constName} = {item.Constant.Value},");
            }

            sb.AppendLine("}");
            sb.AppendLine();
        }

        var enumsPath = Path.Combine(_outputPath, "Enums.g.cs");
        File.WriteAllText(enumsPath, sb.ToString());
        Console.WriteLine($"Generated: {enumsPath}");
    }

    private void GenerateApplePlugins(List<GdClass> classes)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This code was generated by GodotApplePlugins.Generator.");
        sb.AppendLine("// Do not edit this file directly. Edit the generator instead.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Godot;");

        // Add using statements for each namespace, but use aliases to avoid conflicts
        // when a class name matches the namespace short name (e.g., Foundation in GodotApplePlugins.NET.Foundation)
        var namespaces = classes
            .Select(c => TypeMapper.GetNamespace(c.Name))
            .Where(ns => ns != "GodotApplePlugins.NET")
            .Distinct()
            .OrderBy(ns => ns);

        // Track classes that conflict with their namespace short name
        var conflictingClasses = new HashSet<string>();
        foreach (var gdClass in classes)
        {
            var ns = TypeMapper.GetNamespace(gdClass.Name);
            var nsShort = ns.Replace("GodotApplePlugins.NET.", "");
            if (gdClass.Name == nsShort)
            {
                conflictingClasses.Add(gdClass.Name);
            }
        }

        foreach (var ns in namespaces)
        {
            sb.AppendLine($"using {ns};");
        }

        sb.AppendLine();
        sb.AppendLine("namespace GodotApplePlugins.NET;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Main entry point for accessing GodotApplePlugins functionality.");
        sb.AppendLine("/// Provides convenient factory methods for creating wrapper instances.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class ApplePlugins");
        sb.AppendLine("{");

        // Platform check methods
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Checks if the GodotApplePlugins GDExtension is available on this platform.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <returns>True if running on macOS or iOS.</returns>");
        sb.AppendLine("    public static bool IsAvailable()");
        sb.AppendLine("    {");
        sb.AppendLine("        var os = OS.GetName();");
        sb.AppendLine("        return os == \"macOS\" || os == \"iOS\";");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Tries to create a new instance of a GDExtension class by name.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static GodotObject? TryCreateInstance(string className)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (!ClassDB.ClassExists(className))");
        sb.AppendLine("            return null;");
        sb.AppendLine("        return ClassDB.Instantiate(className).AsGodotObject();");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Group by namespace for organization
        var byNamespace = classes.GroupBy(c => TypeMapper.GetNamespace(c.Name));

        foreach (var group in byNamespace)
        {
            var nsShort = group.Key.Replace("GodotApplePlugins.NET.", "");
            if (nsShort == "GodotApplePlugins.NET") nsShort = "Core";

            sb.AppendLine($"    #region {nsShort}");
            sb.AppendLine();

            foreach (var gdClass in group)
            {
                // Use fully qualified name for classes that conflict with their namespace
                var typeName = conflictingClasses.Contains(gdClass.Name)
                    ? $"{TypeMapper.GetNamespace(gdClass.Name)}.{gdClass.Name}"
                    : gdClass.Name;

                // Create method
                sb.AppendLine($"    /// <summary>Creates a {gdClass.Name} wrapper from a GDExtension instance.</summary>");
                sb.AppendLine($"    public static {typeName} Create{gdClass.Name}(GodotObject instance)");
                sb.AppendLine($"        => new(instance);");
                sb.AppendLine();

                // TryCreate method
                sb.AppendLine($"    /// <summary>Creates a new {gdClass.Name} instance if available.</summary>");
                sb.AppendLine($"    public static {typeName}? TryCreate{gdClass.Name}()");
                sb.AppendLine("    {");
                sb.AppendLine($"        var instance = TryCreateInstance(\"{gdClass.Name}\");");
                sb.AppendLine($"        return instance != null ? new {typeName}(instance) : null;");
                sb.AppendLine("    }");
                sb.AppendLine();
            }

            sb.AppendLine("    #endregion");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        var filePath = Path.Combine(_outputPath, "ApplePlugins.g.cs");
        File.WriteAllText(filePath, sb.ToString());
        Console.WriteLine($"Generated: {filePath}");
    }

    private static string EscapeXml(string text)
    {
        return text
            .Replace("&", "&amp;")
            .Replace("<", "&lt;")
            .Replace(">", "&gt;");
    }

    /// <summary>
    /// Extracts type names from a Godot type string (handles Array[Type] etc.)
    /// </summary>
    private void AddReferencedTypes(string godotType, HashSet<string> types)
    {
        if (string.IsNullOrEmpty(godotType) || godotType == "void")
            return;

        // Handle Array[Type]
        var arrayMatch = System.Text.RegularExpressions.Regex.Match(godotType, @"Array\[(\w+)\]");
        if (arrayMatch.Success)
        {
            var innerType = arrayMatch.Groups[1].Value;
            types.Add(innerType);
            return;
        }

        types.Add(godotType);
    }
}
