using System.Text;

namespace GodotApplePlugins.Generator;

/// <summary>
/// Generates C# wrapper code from parsed GdClass models.
/// </summary>
public class CodeGenerator
{
    private readonly string _outputPath;

    public CodeGenerator(string outputPath)
    {
        _outputPath = outputPath;
    }

    /// <summary>
    /// Generates all classes.
    /// </summary>
    public void GenerateAll(List<GdClass> classes)
    {
        // Group by namespace
        var byNamespace = classes.GroupBy(c => TypeMapper.GetNamespace(c.Name));

        foreach (var group in byNamespace)
        {
            var namespaceDir = Path.Combine(_outputPath, group.Key.Replace("GodotApplePlugins.Sharp.", "").Replace(".", "/"));
            Directory.CreateDirectory(namespaceDir);

            foreach (var gdClass in group)
            {
                var code = GenerateClass(gdClass);
                var filePath = Path.Combine(namespaceDir, $"{gdClass.Name}.g.cs");
                File.WriteAllText(filePath, code);
                Console.WriteLine($"Generated: {filePath}");
            }
        }

        // Generate enums file
        GenerateEnums(classes);

        // Generate ApplePlugins factory class
        GenerateApplePlugins(classes);
    }

    /// <summary>
    /// Generates code for a single class.
    /// </summary>
    public string GenerateClass(GdClass gdClass)
    {
        var sb = new StringBuilder();
        var ns = TypeMapper.GetNamespace(gdClass.Name);

        // File header
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This code was generated by GodotApplePlugins.Generator.");
        sb.AppendLine("// Do not edit this file directly. Edit the generator instead.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Godot;");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine();
        sb.AppendLine($"namespace {ns};");
        sb.AppendLine();

        // Class XML doc
        if (!string.IsNullOrEmpty(gdClass.Description))
        {
            sb.AppendLine("/// <summary>");
            foreach (var line in gdClass.Description.Split('\n'))
            {
                sb.AppendLine($"/// {EscapeXml(line.Trim())}");
            }
            sb.AppendLine("/// </summary>");
        }

        // Class declaration
        sb.AppendLine($"public partial class {gdClass.Name}");
        sb.AppendLine("{");

        // Private field
        sb.AppendLine("    private readonly GodotObject _instance;");
        sb.AppendLine();

        // Constructor
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Creates a new {gdClass.Name} wrapper.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public {gdClass.Name}(GodotObject instance)");
        sb.AppendLine("    {");
        sb.AppendLine("        _instance = instance ?? throw new ArgumentNullException(nameof(instance));");

        // Connect signals in constructor
        if (gdClass.Signals.Count > 0)
        {
            sb.AppendLine("        ConnectSignals();");
        }

        sb.AppendLine("    }");
        sb.AppendLine();

        // Instance property
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets the underlying GDExtension object.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public GodotObject Instance => _instance;");
        sb.AppendLine();

        // Generate properties
        foreach (var prop in gdClass.Properties)
        {
            GenerateProperty(sb, prop);
        }

        // Generate methods
        foreach (var method in gdClass.Methods)
        {
            GenerateMethod(sb, method);
        }

        // Generate signal events
        if (gdClass.Signals.Count > 0)
        {
            GenerateSignals(sb, gdClass.Signals);
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private void GenerateProperty(StringBuilder sb, GdProperty prop)
    {
        var csharpType = TypeMapper.GetCSharpType(prop.Type);
        var propName = TypeMapper.ToPascalCase(prop.Name);

        // XML doc
        if (!string.IsNullOrEmpty(prop.Description))
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// {EscapeXml(prop.Description)}");
            sb.AppendLine("    /// </summary>");
        }

        var getterCode = TypeMapper.GetFromGodotConversion($"_instance.Get(new StringName(\"{prop.Name}\"))", prop.Type);

        if (prop.HasSetter)
        {
            var setterConversion = TypeMapper.GetToGodotConversion("value", prop.Type);
            sb.AppendLine($"    public {csharpType} {propName}");
            sb.AppendLine("    {");
            sb.AppendLine($"        get => {getterCode};");
            sb.AppendLine($"        set => _instance.Set(new StringName(\"{prop.Name}\"), {setterConversion});");
            sb.AppendLine("    }");
        }
        else
        {
            sb.AppendLine($"    public {csharpType} {propName} => {getterCode};");
        }

        sb.AppendLine();
    }

    private void GenerateMethod(StringBuilder sb, GdMethod method)
    {
        var methodName = TypeMapper.ToPascalCase(method.Name);
        var returnType = TypeMapper.GetCSharpType(method.ReturnType);
        var hasReturn = method.ReturnType != "void";

        // Check if last param is Callable (callback pattern)
        var isCallbackMethod = method.Parameters.LastOrDefault()?.Type == "Callable";

        // XML doc
        if (!string.IsNullOrEmpty(method.Description))
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// {EscapeXml(method.Description)}");
            sb.AppendLine("    /// </summary>");
        }

        // Build parameter list
        var paramList = new List<string>();
        foreach (var param in method.Parameters)
        {
            if (param.Type == "Callable")
            {
                // Convert callback to Action/Func
                paramList.Add($"Action? {TypeMapper.ToCamelCase(param.Name)} = null");
            }
            else
            {
                var paramType = TypeMapper.GetCSharpType(param.Type);
                var paramName = TypeMapper.ToCamelCase(param.Name);

                // Avoid C# reserved keywords
                if (paramName == "params") paramName = "@params";
                if (paramName == "event") paramName = "@event";
                if (paramName == "class") paramName = "@class";

                paramList.Add($"{paramType} {paramName}");
            }
        }

        var paramsStr = string.Join(", ", paramList);
        sb.AppendLine($"    public {returnType} {methodName}({paramsStr})");
        sb.AppendLine("    {");

        // Build call arguments
        var callArgs = new List<string>();
        callArgs.Add($"new StringName(\"{method.Name}\")");

        foreach (var param in method.Parameters)
        {
            var paramName = TypeMapper.ToCamelCase(param.Name);
            if (paramName == "params") paramName = "@params";
            if (paramName == "event") paramName = "@event";
            if (paramName == "class") paramName = "@class";

            if (param.Type == "Callable")
            {
                callArgs.Add($"{paramName} != null ? Callable.From(() => {paramName}()) : Callable.From(() => {{ }})");
            }
            else
            {
                callArgs.Add(TypeMapper.GetToGodotConversion(paramName, param.Type));
            }
        }

        var callArgsStr = string.Join(", ", callArgs);

        if (hasReturn)
        {
            sb.AppendLine($"        var result = _instance.Call({callArgsStr});");
            var conversion = TypeMapper.GetFromGodotConversion("result", method.ReturnType);
            sb.AppendLine($"        return {conversion};");
        }
        else
        {
            sb.AppendLine($"        _instance.Call({callArgsStr});");
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private void GenerateSignals(StringBuilder sb, List<GdSignal> signals)
    {
        sb.AppendLine("    #region Signals");
        sb.AppendLine();

        // Generate event declarations
        foreach (var signal in signals)
        {
            var eventName = TypeMapper.ToPascalCase(signal.Name);

            if (!string.IsNullOrEmpty(signal.Description))
            {
                sb.AppendLine("    /// <summary>");
                sb.AppendLine($"    /// {EscapeXml(signal.Description)}");
                sb.AppendLine("    /// </summary>");
            }

            if (signal.Parameters.Count == 0)
            {
                sb.AppendLine($"    public event Action? {eventName};");
            }
            else
            {
                var typeParams = string.Join(", ", signal.Parameters.Select(p => TypeMapper.GetCSharpType(p.Type)));
                sb.AppendLine($"    public event Action<{typeParams}>? {eventName};");
            }

            sb.AppendLine();
        }

        // Generate ConnectSignals method
        sb.AppendLine("    private void ConnectSignals()");
        sb.AppendLine("    {");

        foreach (var signal in signals)
        {
            var eventName = TypeMapper.ToPascalCase(signal.Name);
            var handlerName = $"On{eventName}";

            if (signal.Parameters.Count == 0)
            {
                sb.AppendLine($"        _instance.Connect(new StringName(\"{signal.Name}\"),");
                sb.AppendLine($"            Callable.From(() => {eventName}?.Invoke()));");
            }
            else
            {
                // Build Callable.From with proper types
                var paramTypes = string.Join(", ", signal.Parameters.Select(p =>
                {
                    // For Callable.From, we need the raw Godot types, not wrapped
                    return p.Type switch
                    {
                        _ when TypeMapper.IsWrappedClass(p.Type) => "GodotObject",
                        "Array" => "Godot.Collections.Array",
                        _ when p.Type.StartsWith("Array[") => "Godot.Collections.Array",
                        _ => TypeMapper.GetCSharpType(p.Type)
                    };
                }));

                var paramNames = signal.Parameters.Select((p, i) => $"p{i}").ToList();
                var paramNamesStr = string.Join(", ", paramNames);

                // Build invocation with conversions
                var invokeArgs = signal.Parameters.Select((p, i) =>
                {
                    if (TypeMapper.IsWrappedClass(p.Type))
                    {
                        return $"new {p.Type}(p{i})";
                    }
                    else if (p.Type.StartsWith("Array["))
                    {
                        var innerType = p.Type.Replace("Array[", "").Replace("]", "");
                        if (TypeMapper.IsWrappedClass(innerType))
                        {
                            return $"p{i}.Select(x => new {innerType}((GodotObject)x.Obj!)).ToArray()";
                        }
                        return $"p{i}.Select(x => x.As<{TypeMapper.GetCSharpType(innerType)}>()).ToArray()";
                    }
                    return $"p{i}";
                });
                var invokeArgsStr = string.Join(", ", invokeArgs);

                sb.AppendLine($"        _instance.Connect(new StringName(\"{signal.Name}\"),");
                sb.AppendLine($"            Callable.From<{paramTypes}>(({paramNamesStr}) =>");
                sb.AppendLine($"                {eventName}?.Invoke({invokeArgsStr})));");
            }

            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    #endregion");
    }

    private void GenerateEnums(List<GdClass> classes)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This code was generated by GodotApplePlugins.Generator.");
        sb.AppendLine("// Do not edit this file directly. Edit the generator instead.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("namespace GodotApplePlugins.Sharp;");
        sb.AppendLine();

        // Group constants by enum name
        var enumGroups = classes
            .SelectMany(c => c.Constants.Select(k => (Class: c, Constant: k)))
            .Where(x => !string.IsNullOrEmpty(x.Constant.EnumName))
            .GroupBy(x => $"{x.Class.Name}.{x.Constant.EnumName}");

        foreach (var group in enumGroups)
        {
            var enumName = group.Key.Split('.').Last();
            var className = group.Key.Split('.').First();

            sb.AppendLine($"/// <summary>");
            sb.AppendLine($"/// Enum from {className}.");
            sb.AppendLine($"/// </summary>");
            sb.AppendLine($"public enum {className}{enumName}");
            sb.AppendLine("{");

            foreach (var item in group)
            {
                var constName = TypeMapper.ToPascalCase(item.Constant.Name);
                if (!string.IsNullOrEmpty(item.Constant.Description))
                {
                    sb.AppendLine($"    /// <summary>{EscapeXml(item.Constant.Description)}</summary>");
                }
                sb.AppendLine($"    {constName} = {item.Constant.Value},");
            }

            sb.AppendLine("}");
            sb.AppendLine();
        }

        var enumsPath = Path.Combine(_outputPath, "Enums.g.cs");
        File.WriteAllText(enumsPath, sb.ToString());
        Console.WriteLine($"Generated: {enumsPath}");
    }

    private void GenerateApplePlugins(List<GdClass> classes)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This code was generated by GodotApplePlugins.Generator.");
        sb.AppendLine("// Do not edit this file directly. Edit the generator instead.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Godot;");

        // Add using statements for each namespace
        var namespaces = classes
            .Select(c => TypeMapper.GetNamespace(c.Name))
            .Where(ns => ns != "GodotApplePlugins.Sharp")
            .Distinct()
            .OrderBy(ns => ns);

        foreach (var ns in namespaces)
        {
            sb.AppendLine($"using {ns};");
        }

        sb.AppendLine();
        sb.AppendLine("namespace GodotApplePlugins.Sharp;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Main entry point for accessing GodotApplePlugins functionality.");
        sb.AppendLine("/// Provides convenient factory methods for creating wrapper instances.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class ApplePlugins");
        sb.AppendLine("{");

        // Platform check methods
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Checks if the GodotApplePlugins GDExtension is available on this platform.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <returns>True if running on macOS or iOS.</returns>");
        sb.AppendLine("    public static bool IsAvailable()");
        sb.AppendLine("    {");
        sb.AppendLine("        var os = OS.GetName();");
        sb.AppendLine("        return os == \"macOS\" || os == \"iOS\";");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Tries to create a new instance of a GDExtension class by name.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static GodotObject? TryCreateInstance(string className)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (!ClassDB.ClassExists(className))");
        sb.AppendLine("            return null;");
        sb.AppendLine("        return ClassDB.Instantiate(className).AsGodotObject();");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Group by namespace for organization
        var byNamespace = classes.GroupBy(c => TypeMapper.GetNamespace(c.Name));

        foreach (var group in byNamespace)
        {
            var nsShort = group.Key.Replace("GodotApplePlugins.Sharp.", "");
            if (nsShort == "GodotApplePlugins.Sharp") nsShort = "Core";

            sb.AppendLine($"    #region {nsShort}");
            sb.AppendLine();

            foreach (var gdClass in group)
            {
                // Create method
                sb.AppendLine($"    /// <summary>Creates a {gdClass.Name} wrapper from a GDExtension instance.</summary>");
                sb.AppendLine($"    public static {gdClass.Name} Create{gdClass.Name}(GodotObject instance)");
                sb.AppendLine($"        => new(instance);");
                sb.AppendLine();

                // TryCreate method
                sb.AppendLine($"    /// <summary>Creates a new {gdClass.Name} instance if available.</summary>");
                sb.AppendLine($"    public static {gdClass.Name}? TryCreate{gdClass.Name}()");
                sb.AppendLine("    {");
                sb.AppendLine($"        var instance = TryCreateInstance(\"{gdClass.Name}\");");
                sb.AppendLine($"        return instance != null ? new {gdClass.Name}(instance) : null;");
                sb.AppendLine("    }");
                sb.AppendLine();
            }

            sb.AppendLine("    #endregion");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        var filePath = Path.Combine(_outputPath, "ApplePlugins.g.cs");
        File.WriteAllText(filePath, sb.ToString());
        Console.WriteLine($"Generated: {filePath}");
    }

    private static string EscapeXml(string text)
    {
        return text
            .Replace("&", "&amp;")
            .Replace("<", "&lt;")
            .Replace(">", "&gt;");
    }
}
